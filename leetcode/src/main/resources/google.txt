一个image以2D byte array的方式储存（byte[][] image），每个象素点是1个bit（0或1）。现在要求每行的象素点做对称翻转。我的做法是先把每行的byte对称翻转，然后再把每个byte各自翻转。
如其中一行byte[] row = {11010100，00101010} 第一步{00101010，11010100} 第二步{01010100，00101011} 时间复杂度是O(mn8), follow up如何优化时间，应该是在翻转每个byte上把O（8）的复杂度降低，但是不要求使用复杂的位运算。
2. game of life变形，一个2D matrix只有0或1，要求把所有上下左右被1包围的1变成0。先给了个space O（n^2）暴力解，然后让优化空间，就说了用两个bit存放前后state的方法，space变O（1），但面试官说假设每个格子只有一个bit空间怎么办？答三行三行做，他说行。
3. 面经题，设计一个interface实现有timestamp的hashmap，即（key，value，time），写出get和 put方法。过期的key value pair不能被get。
4. 面经题，给一个国王家的family tree （n-ary tree），王位继承是先传国王最年长的儿子，假如最年长儿子死了，就传给死儿子最年长的儿子。。。如果这些人都不存在，再考虑国王次年长的儿子，以此类推。要求设计这样一棵树，死掉的人不要求删除，实现birth（）和输出王位继承顺序的method（死掉的人不在继承顺序结果里）。